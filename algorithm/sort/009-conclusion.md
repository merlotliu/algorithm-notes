---
layout: post
title: 排序算法总结
date: 2023-12-13 00:14:33
updated: 2023-02-27 00:14:33
tags: [排序算法]
categories: [算法&数据结构]
comments: true
---

## 排序算法总结

### 稳定性

所谓稳定性，是指相同值在排序前后，其相对位置是否改变。发生改变则不存在稳定性，不发生变化则稳定。

例如：{1, 5, 3, 5, 2, 4}，如果在通过排序算法A排序后，第一个5移动到了第二个后面，则不稳定，反之稳定。

#### 不稳定排序

选择排序：如{3, 3, 3, 1, 3, 3}，在第一轮变化后，第一个3会移动到1的位置。

快速排序：如{5, 5, 5, 3, 2}，在基准值为5的情况下，第一次划分后，第一个5会移动到3的位置，即原来第三个5的右边。

堆排序：如{5, 4, 4, 6}，在进行 heap insert的过程中，6会与第一个4交换，导致第一个4到达原来第二个4的右边。

#### 稳定排序

冒泡排序、插入排序、归并排序、基于桶的排序

### 排序算法时间、空间复杂度及稳定性

|          | 时间复杂度 | 空间复杂度 | 稳定性 |
| :------: | :--------: | :--------: | :----: |
| 选择排序 |   O(N^2)   |    O(1)    |   X    |
| 冒泡排序 |   O(N^2)   |    O(1)    |   √    |
| 插入排序 |   O(N^2)   |    O(1)    |   √    |
| 归并排序 | O(N*logN)  |    O(N)    |   √    |
| 快速排序 | O(N*logN)  |  O(logN)   |   X    |
|  堆排序  | O(N*logN)  |    O(1)    |   X    |

### Tips

目前，不低于时间复杂度O(N*logN)的排序算法。

也不存在时间复杂度O(N*logN)、空间复杂度O(1)且稳定的排序算法。

所以，目前来说后三种算法在不同场合下各有优劣。

- 小样本使用**插入排序**；
- 需要稳定性且高效时，使用**归并排序**；
- 普通大量数据使用**快速排序**（通常都是用快排，因为在大量测试下，快排的常数项是最小的）；
- 有内存限制的时候，使用**堆排序**；

### 工程应用中的排序

- 结合不同算法的优劣；
- 稳定性的考虑；

一些语言中或工程中内置的排序算法，通常是结合不同算法优劣产生的算法。

如在大量数据的时候采用快排划分数据，当数据到达小样本的范围，在使用插入排序。

或是普通数据采用快排，类等复杂结构使用归并（这是为了利用其稳定性，比如筛选商品，先筛选好评多的，在筛选便宜的，这样我们就能在好评多的基础上得到最便宜的商品）。

### 常见的坑

1. 归并排序内部缓存；（降低归并的空间复杂度为O(1)，会变得不稳定）
2. 01 stable sort；（快排稳定版，会使得空间复杂度上升为O(N)）
3. 奇数放在数组左边，偶数放在数组右边，保证原始次序不变。（01 stable sort）