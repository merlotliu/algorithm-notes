---
layout: post
title: 买卖股票问题
date: 2022-12-13 00:14:33
updated: 2023-03-21 00:14:33
tags: [买卖股票问题, leetcode]
categories: [算法&数据结构]
comments: true
---

## 买卖股票问题
### 买卖股票的最佳时机 II & 含手续费

[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候最多只能持有一股股票。你也可以先购买，然后在同一天出售。

返回你能获得的最大利润 。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

**提示：**

- `1 <= prices.length <= 3 * 104`
- `0 <= prices[i] <= 104`

#### 题解

##### dp数组含义

dp\[i][0] 表示第 i 天，持有股票的情况下，手头上的最大现金；

dp\[i][1] 表示第 i 天，不持有股票的情况下，手头上的最大现金；

##### base case

dp\[-1][1] 和 dp\[-1][0] 都在第一天之前，不存在购买和出售的情况，则 dp\[-1][1] 为 0，而 dp\[-1][0] 需为一个数组的全局最小值，否则第一次购入股票的值时，由于手上现金数为负数，最后结果一定为 0；

因为数组不存在下标 -1，所以我们可以选择为 dp 数组的长度 + 1，或以第 1 天的情况为 base case；

第一天为 base case的话：

- dp\[0][0] 表示第一天持有股票的情况下，手上最大现金，那么肯定是 -prices\[0]： dp\[0][0] = -prices\[0]；

- dp\[0][1] 表示第一天不持有股票的情况下，手上最大现金，那么肯定是 0：dp\[0][1] = 0；

##### 转移方程

对于**第 i 天持有股票** dp\[i][0] 的情况下，其可能获得最大收益的方式：

- 前一天持有股票 dp\[i-1][0]；
- 前一天不持有股票而今天买入 dp\[i-1][1] - prices[i];

即 dp\[i][0] = max(dp\[i-1][0], dp\[i-1][1] - prices[i]);

对于**第 i 天不持有股票** dp\[i][1] 的情况下，其可能获得最大收益的方式：

- 前一天不持有股票 dp\[i-1][1]；
- 前一天持有股票而今天卖出 dp\[i-1][0] + prices[i];

即 dp\[i][1] = max(dp\[i-1][1], dp\[i-1][0] + prices[i]);

如果含**手续费**的情况下，仅需要在售出时减去手续费 fee 即可，即 dp\[i][1] = max(dp\[i-1][1], dp\[i-1][0] + prices[i] - fee);

**注意**：

dp数组中的表示手上最大现金收益，如果是在购买股票之后，则其一定是扣除购入股票之后的值，也就是说可能是负数；

这样在后面卖出股票时，股票的价格就是本次出售的净收益。

##### 结果

最后一天在不持有股票的状态下一定是收益最大的，即 dp\[prices.size() - 1][1];

#### 代码

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() == 0) return 0;
        /// dp[i][0] 表示第 i 天，持有股票的情况下，手头上的最大现金；
        /// dp[i][1] 表示第 i 天，不持有股票的情况下，手头上的最大现金；
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        /// 第一天为 base case的话：
        /// dp[0][0] 表示第一天持有股票的情况下，手上最大现金，那么肯定是 -prices[0]; 
        /// dp[0][1] 表示第一天不持有股票的情况下，手上最大现金，那么肯定是 0;
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < prices.size(); i++) {
            /// 对于第 i 天持有股票 dp[i][0] 的情况下，其可能获得最大收益的方式：
            /// 前一天持有股票 dp[i-1][0]；
            /// 前一天不持有股票而今天买入 dp[i-1][1] - prices[i];
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            /// 对于第 i 天不持有股票 dp[i][1] 的情况下，其可能获得最大收益的方式：
            /// 前一天不持有股票 dp[i-1][1]；
            /// 前一天持有股票而今天卖出 dp[i-1][0] + prices[i]（如果含有手续费，减去手续费即可: dp[i-1][0] + prices[i] - fee）;
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
          	// dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee); /// 有手续费的情况
            // cout << dp[i][0] << " " << dp[i][1] << endl;
        }
        return dp[prices.size() - 1][1];
    }
};
```

### 买卖股票的最佳时机 III & IV

[123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/)

给定一个整数数组 `prices` ，它的第 `i` 个元素 `prices[i]` 是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**提示：**

- `0 <= k <= 100`
- `0 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`

#### 题解

##### dp数组含义

dp\[i][j\*2] 表示第 i 天状态为第 j 次持有股票时获得的最大收益;

dp\[i][j\*2+1] 表示第 i 天状态为第 j 次出售完股票获得的最大收益;

##### base case

dp\[-1][2*j] = INT_MIN 表示一个全局最小，因为在第一次购入股票时，持有现金最大收益一定是负数，这样在取两者最大值时，才能够将第一次的股票购入；

dp\[-1][2*j+1] = 0 表示未进行购入和出售的操作，收益最大为 0；

如果以第一天作为 base，将每一次购入股票赋值为第一天购入股票的最大收益，即 dp\[-1][2*j] = -prices[0] 即可。

第一次持有股票的 base 为购入第一天股票后的负收益很好理解，那么为什么多次持有股票的 base 也是购入第一天股票后的负收益？

我们可以理解为，第一天多次购入、出售，而此时，持有股票的情况下，最大收益仍然是购入第一天股票后的负收益。

##### 转移方程

第 i 天状态为第 j 次持有股票时获得的最大收益 dp\[i][j\*2] 来自以下两者最大值：

- 前一天（第 i-1 天）状态为第 j 次持有股票时获得的最大收益：dp\[i-1][j\*2]；
- 前一天（第 i-1 天）状态为第 j - 1 次出售完股票获得的最大收益，并购入今日的股票：dp\[i-1][j\*2-1] - prices[i]；

即 dp\[i][j\*2] = max(dp\[i-1][j\*2], dp\[i-1][j\*2-1] - prices[i]);

第 i 天状态为第 j 次出售完股票获得的最大收益 dp\[i][j\*2+1] 来自以下两者最大值：

- 前一天（第 i-1 天）状态为第 j 次出售完股票获得的最大收益：dp\[i-1][j\*2+1]；

- 前一天（第 i-1 天）状态为第 j 次持有股票时获得的最大收益，并在今日出售：dp\[i-1][j\*2] + prices[i]；

即 dp\[i][j\*2+1] = max(dp\[i-1][j\*2+1], dp\[i-1][j\*2] + prices[i]);

##### 结果

购买出售 k 次股票获得的最大收益一定是最大的。我们可以作如下假设：

假设买卖 k-1 次最大，那么我们直接再购买一次股票出售一次不就变成 k 次了，所以 k 次一定大于等于 k-1 的；

即  dp\[prices.size() - 1][k * 2 + 1]；

#### 代码

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        if(prices.size() == 0) return 0;
        /// dp[i][j*2] 表示第 i 天状态为第 j 次持有股票时获得的最大收益
        /// dp[i][j*2+1] 表示第 i 天状态为第 j 次出售完股票获得的最大收益
      	/// 这里我们申请的长度为 (k + 1) * 2，这是为了简化判断第一次购入的情况，否则 j*2-1 < 0 时需要判断
        vector<vector<int>> dp(prices.size(), vector<int>((k + 1) * 2, 0));
      	/// 第一次持有股票的 base 为购入第一天股票后的负收益
     		/// 多次持有股票的 base 也是购入第一天股票后的负收益: 
      	/// 理解为，第一天多次购入、出售，而此时，持有股票的情况下，最大收益仍然是购入第一天股票后的负收益
      	/// 不持有股票的 base 为 0，第一天不管是多次出售购买还是未进行操作，最大收益肯定是 0
        for(int j = 1; j <= k; j++) {
            dp[0][j*2] = -prices[0];
        }
        for(int i = 1; i < prices.size(); i++) {
            for(int j = 1; j <= k; j++) {
                /// 第 i 天状态为第 j 次持有股票时获得的最大收益 dp[i][j*2] 来自以下两者最大值：
                /// 前一天（第 i-1 天）状态为第 j 次持有股票时获得的最大收益：dp[i-1][j*2]；
                /// 前一天（第 i-1 天）状态为第 j - 1 次出售完股票获得的最大收益，并购入今日的股票：dp[i-1][j*2-1] - prices[i]；
                dp[i][j*2] = max(dp[i-1][j*2], dp[i-1][j*2-1] - prices[i]);
                /// 第 i 天状态为第 j 次出售完股票获得的最大收益 dp[i][j*2+1] 来自以下两者最大值：
                /// 前一天（第 i-1 天）状态为第 j 次出售完股票获得的最大收益：dp[i-1][j*2+1]；
                /// 前一天（第 i-1 天）状态为第 j 次持有股票时获得的最大收益，并在今日出售：dp[i-1][j*2] + prices[i]；
                dp[i][j*2+1] = max(dp[i-1][j*2+1], dp[i-1][j*2] + prices[i]);
                // cout << dp[i][j*2] << " " << dp[i][j*2+1] << " ";
            }
            // cout << endl;
        }
        /// 第 k 次出售完股票获得的最大收益一定是最大的
        /// 假设第 k-1 次最大，那么我们直接再购买一次股票出售一次不就变成 k 次了
        /// 所以 k 次一定是包含 k-1 的 
        return dp[prices.size() - 1][k * 2 + 1];
    }
};
```

### 最佳买卖股票时机含冷冻期

[309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

 **提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`

#### 题解

每天的状态大概可以分为：持有股票的状态、今天**无操作**导致不持有股票的状态、今天**售出**导致不持有股票的状态。

##### dp数组含义

dp\[i][0] 表示持有股票的状态。

dp\[i][1] 表示今天**无操作**导致不持有股票的状态。

dp\[i][2] 表示今天**售出**导致不持有股票的状态。

##### base case

第一天持有股票的情况 dp\[i][0] = -prices[0]。

第一天**无操作**导致不持有股票的状态 dp\[i][1] = 0。

今天**售出**导致不持有股票的状态（可以视为购买又出售） dp\[i][2] = 0。

##### 转移方程

持有股票的状态 dp\[i][0] 可以来自：

- 前一天持有股票的状态： dp\[i - 1][0]。
- 前一天**无操作**导致不持有股票的状态，并在今天购买：dp\[i-1][1] - prices[i]。

即 dp\[i][0] = max(dp\[i - 1][0], dp\[i-1][1] - prices[i]);

今天**无操作**导致不持有股票的状态 dp\[i][1] 可以来自：

- 前一天**无操作**导致不持有股票的状态：dp\[i - 1][1]。
- 前一天**售出**导致不持有股票的状态，并在今天**无操作**：dp\[i - 1][2]。

即 dp\[i][1] = max(dp\[i - 1][1], dp\[i - 1][2]);

今天**售出**导致不持有股票的状态 dp\[i][2] 一定来自：

- 前一天持有股票的状态，并在今天售出：dp\[i-1][0] + prices[i]。

即 dp\[i][2] = dp\[i-1][0] + prices[i];

##### 结果

最后一天不持有股票的两种状态都有可能是最大值，故 max(dp\[n-1][1], dp\[n-1][2]);

#### 代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        /// dp[i][0] 表示持有股票的状态。
        /// dp[i][1] 表示今天 无操作 导致不持有股票的状态。
        /// dp[i][2] 表示今天 售出 导致不持有股票的状态。
        vector<vector<int>> dp(n, vector<int>(3, 0));
        /// 第一天持有股票的情况 dp[i][0] = -prices[0]。
        /// 第一天无操作导致不持有股票的状态 dp[i][1] = 0。
        /// 今天售出导致不持有股票的状态（可以视为购买又出售） dp[i][2] = 0。
        dp[0][0] = -prices[0];
        for(int i = 1; i < n; i++) {
            /// 持有股票的状态 dp\[i][0] 可以来自：
            /// - 前一天持有股票的状态： dp [i - 1][0]。
            /// - 前一天 无操作 导致不持有股票的状态，并在今天购买：dp [i-1][1] - prices[i]。
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            /// 今天 无操作 导致不持有股票的状态 dp [i][1] 可以来自：
            /// - 前一天 无操作 导致不持有股票的状态：dp [i - 1][1]。
            /// - 前一天 售出 导致不持有股票的状态，并在今天 无操作 ：dp [i - 1][2]。
            dp[i][1] = max(dp[i-1][1], dp[i-1][2]);
            /// 今天 售出 导致不持有股票的状态 dp [i][2] 一定来自：
            /// - 前一天持有股票的状态，并在今天售出：dp [i-1][0] + prices[i]。
            dp[i][2] = dp[i-1][0] + prices[i];
        }
        /// 最后一天不持有股票的两种状态都有可能是最大值
        return max(dp[n-1][1], dp[n-1][2]);
    }
};
```

